# **Алгоритм создания Продуктового Задания (PRD)** 

## **Содержит приложение: универсальный Шаблон (Template)**, 

# Часть 1\. Алгоритм создания PRD (The Mellow Process)

Этот алгоритм основан на опыте создания продуктового задания с использованием LLM путем продвижения от широкого контекста к деталям, через итерации и утверждения.

## Шаг 1\. Погружение и Синхронизация (Context & Alignment)

* **Действие:** Загрузка всех стратегических вводных (Vision, Positioning, GTM, Strategy, and description of existing modules and how it works descriptions and if applicable confluence docs) и описание текстом в промте новой фичи "своими словами".  
* **Цель:** ИИ должен понять не просто "что делать", а "зачем" и "как это вписывается в текущую платформу [Mellow.io](http://Mellow.io) и продукт".  
* **Чек-пойнт:** ИИ возвращает *Concept Summary* (краткое изложение сути), и вы утверждаете: "Да, это то, что я имел в виду, давай переходить к следующему шагу" Или уточняете и поправляете. Если прозвучало утверждение, то ЛЛМ оглашает короткий план следующего шага и ожидает ввода промта. В ответ получает или команду начинать или команду начинать вместе с набором дополнительных данных и/или документов для более глубокого погружения в контекст, или получает предложение по изменению алгоритма предстоящего шага.

## Шаг 2\. создание скелета документа (Structuring)

* **Действие:** Предложение структуры разделов (оглавления) с кратким пояснением, что будет внутри.  
* **Цель:** Согласовать логику будущего повествования до написания полного текста.  
* **Чек-пойнт:** Утверждение списка разделов. (Например: "Утверждаю, но давай добавим раздел про негативные сценарии"). В итоге вы утверждаете: "Да, это то, что нужно, давай переходить к следующему шагу" Или уточняете и поправляете. процесс перехода к следующему шагу аналогичен: вы утверждаете: "давай переходить к следующему шагу" Или уточняете и поправляете. Если прозвучало утверждение, то ЛЛМ оглашает короткий план следующего шага и ожидает ввода промта. В ответ получает или команду начинать или команду начинать вместе с набором дополнительных данных и/или документов для более глубокого погружения в контекст, или получает предложение по изменению алгоритма предстоящего шага.

## Шаг 3\. Драфтинг по блокам (Iterative Drafting)

* **Действие:** Написание текста разделами (по 1 разделу за раз), а не всего документа сразу.  
* **Метод:** "Problem → Solution → Execution". Сначала описываем проблему и роли, затем сценарии, затем технические требования. К визуализации реализации переходим только на шаге 5  
* **Чек-пойнт:** Прямое утверждение каждого блока ("Раздел 3 принят, идем дальше" при этом процедура перехода к следующему шагу такая же как и на предыдущих шагах).

## Шаг 4\. Критическая проверка и "Unhappy Paths" (Stress Test)

* **Действие:** Взгляд на документ глазами “Экспертного совета”, состоящего из:  стратега, инженера, юриста, финансиста/бухгалтера/аудитора  маркетолога и саппорта. При этом мы понимаем что экспертиза некоторых членов Экспертного совета в конкретных ситуациях может быть не востребована, тогда этот эксперт высказывается коротко: это не затрагивает мою компетенцию” \- в выдаче стратег-эксперт делает саммари мнений экспертов, указывая на наличествующие особые мнения с указанием роли эксперта или на особые предупреждения и/или замечания если таковые имеются  
* **Вопросы:** "А что, если процесс пойдет не по основному сценарию?", "что может пойти не так и как это предотвратить/минимизировать?", "Как защитить данные?" и так далее.  
* **Результат:** Появление раздела "Edge Cases / Negative Scenarios".

## Шаг 5\. Визуализация и Код (Prototyping)

* **Действие:** Перевод текста в визуальные артефакты (описание мокапов) и код (HTML/Tailwind). Тут важно принять за основу что мы не пробуем на этом шаге применять дизайн-решения, мы создаем базовую визуализацию через черно-белые мокапы в которых важно видеть визуальную реализацию пользовательского интерфейса с конкретными пропорциями, местами размещения блоков и элементов с вариантами для десктоп и мобильного экранов отдельно при этом начинаем с десктоп версии как более полной и нагруженной  
* **Цель:** Устранить разночтения между "написано" и "представлено". Текст может быть понят по-разному, код/картинка — однозначны.

# Часть 2\. Бриф на старте (Input Brief)

Перед тем как просить кого-то (человека или ИИ) написать PRD, дай ему эти вводные. Это сэкономит 80% времени на уточнения.

**1\. Контекст (The Why)**

* Какую бизнес-проблему решаем? (Например: "Высокий отток на пустой выдаче").  
* Как это связано с глобальной стратегией? (Например: "Переход к модели Human-in-the-Loop").

**2\. Суть фичи/модуля/процесса (The What)**

* Краткое описание "в лифте" (Elevator Pitch).  
* Ключевые отличия от текущего состояния (Current State vs Future State).

**3\. Целевая аудитория (The Who)**

* Кто основной пользователь? (Клиент, Админ, Подрядчик).  
* Какую эмоцию мы хотим вызвать? (Ощущение "магии", "спокойствия", "скорости" “простоты”).

**4\. Артефакты (The Inputs)**

* Ссылки на существующие документы, дизайн-системы, метрики или результаты исследований.

# Часть 3\. Универсальный Шаблон Продуктового Задания (PRD Template)

Используй эту структуру для любой фичи в Mellow. Она покрывает все: от бизнеса до пикселей.

#### **1\. Введение и Обоснование (Introduction & Context)**

* **Проблема (Problem Statement):** Что болит у пользователя или бизнеса?  
* **Решение (Proposed Solution):** Краткая суть функционала.  
* **Цели (Goals):** Чего хотим достичь (качественно).  
* **Метрики успеха (KPIs / Success Metrics):** Как измерим успех в цифрах (Definition of Done).

#### **2\. Ролевая модель и Права (Roles & Permissions)**

* **Акторы:** Кто участвует (User, Admin, System/AI).  
* **Матрица прав:** Кто что может видеть и делать.

#### **3\. Пользовательские сценарии (User Stories & Flows)**

* **Happy Path:** Идеальный сценарий прохождения (шаг за шагом).  
* **Implicit Flow (если есть):** Что происходит "под капотом" без участия пользователя.  
* **Entry Points:** Откуда пользователь попадает в этот сценарий.

#### **4\. Функциональные требования: Frontend (Client-Side)**

* **UI Состояния:**  
  * Zero State (пусто).  
  * Loading State (загрузка).  
  * Active State (работа).  
  * Success State (успех).  
* **Взаимодействия:** Реакции на клики, модальные окна, уведомления.

#### **5\. Функциональные требования: Backend & Admin (Server-Side)**

* **Логика и Алгоритмы:** Как система принимает решения (например, логика назначения тикетов, формула скоринга).  
* **Админ-панель:** Инструменты для Ops-команды (кнопки, таблицы, фильтры).  
* **Работа с данными:** Какие сущности создаются, изменяются или удаляются.

#### **6\. Негативные сценарии и Обработка ошибок (Edge Cases)**

* **Fail States:** Что если что-то пошло не так (таймер истек, оплата не прошла)?  
* **Ошибки:** Тексты ошибок и пути решения для пользователя.  
* **Безопасность:** Ограничения, валидация, приватность.

#### **7\. Интеграции и Уведомления (Integrations & Notifications)**

* **Внешние сервисы:** API, платежки, календари.  
* **Матрица уведомлений:** Кому, когда и где (Email, Push, In-app) отправляем сообщения.

#### **8\. Дизайн и UX-гайдлайны (Design Specs)**

* **Стилистика:** Референсы, тон коммуникации (Tone of Voice).  
* **Ключевые экраны:** Список макетов для отрисовки.

